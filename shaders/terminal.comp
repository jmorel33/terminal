
vec4 UnpackColor(uint c) {
    return vec4(float(c & 0xFF), float((c >> 8) & 0xFF), float((c >> 16) & 0xFF), float((c >> 24) & 0xFF)) / 255.0;
}

void main() {
    // Bindless Accessors
    KTermBuffer terminal_data = KTermBuffer(pc.terminal_buffer_addr);
    sampler2D font_texture = sampler2D(pc.font_texture_handle);
    sampler2D sixel_texture = sampler2D(pc.sixel_texture_handle);

    uvec2 pixel_coords = gl_GlobalInvocationID.xy;
    if (pixel_coords.x >= uint(pc.screen_size.x) || pixel_coords.y >= uint(pc.screen_size.y)) return;

    vec2 uv_screen = vec2(pixel_coords) / pc.screen_size;

    // Load existing background (Z < 0 images)
    vec4 existing_color = imageLoad(output_image, ivec2(pixel_coords));

    // CRT Curvature Effect
    if (pc.crt_curvature > 0.0) {
        vec2 d = abs(uv_screen - 0.5);
        d = pow(d, vec2(2.0));
        uv_screen -= 0.5;
        uv_screen *= 1.0 + dot(d, d) * pc.crt_curvature;
        uv_screen += 0.5;
        if (uv_screen.x < 0.0 || uv_screen.x > 1.0 || uv_screen.y < 0.0 || uv_screen.y > 1.0) {
            imageStore(output_image, ivec2(pixel_coords), vec4(0.0));
            return;
        }
    }

    // Sixel Overlay Sampling (using possibly distorted UV)
    vec4 sixel_color = texture(sixel_texture, uv_screen);

    // Re-calculate cell coordinates based on distorted UV or original pixel coords
    // If CRT is on, we should sample based on distorted UV to map screen to terminal grid
    uvec2 sample_coords = uvec2(uv_screen * pc.screen_size);

    uint cell_x = sample_coords.x / uint(pc.char_size.x);
    uint cell_y = sample_coords.y / uint(pc.char_size.y);
    uint row_start = cell_y * uint(pc.grid_size.x);

    if (row_start >= uint(pc.grid_size.x * pc.grid_size.y)) return;

    // Check line attributes from the first cell of the row
    uint line_flags = terminal_data.cells[row_start].flags;
    bool is_dw = (line_flags & (1 << 7)) != 0;
    bool is_dh_top = (line_flags & (1 << 8)) != 0;
    bool is_dh_bot = (line_flags & (1 << 9)) != 0;

    uint eff_cell_x = cell_x;
    uint in_char_x = sample_coords.x % uint(pc.char_size.x);
    if (is_dw) {
        eff_cell_x = cell_x / 2;
        in_char_x = (sample_coords.x % (uint(pc.char_size.x) * 2)) / 2;
    }

    uint cell_index = row_start + eff_cell_x;
    if (cell_index >= uint(pc.grid_size.x * pc.grid_size.y)) return;

    GPUCell cell = terminal_data.cells[cell_index];
    vec4 fg = UnpackColor(cell.fg_color);
    vec4 bg = UnpackColor(cell.bg_color);
    uint flags = cell.flags;

    if ((flags & (1 << 1)) != 0) { fg.rgb *= 0.5; }
    if ((flags & (1 << 15)) != 0) { bg.rgb *= 0.5; }

    if ((flags & (1 << 5)) != 0) { vec4 t=fg; fg=bg; bg=t; }

    // Mouse Selection Highlight
    if (pc.sel_active != 0) {
        uint s = min(pc.sel_start, pc.sel_end);
        uint e = max(pc.sel_start, pc.sel_end);
        if (cell_index >= s && cell_index <= e) {
             // Invert colors for selection
             fg = vec4(1.0) - fg;
             bg = vec4(1.0) - bg;
             fg.a = 1.0; bg.a = 1.0;
        }
    }

    if (cell_index == pc.cursor_index && pc.cursor_blink_state != 0) {
        vec4 t=fg; fg=bg; bg=t;
    }

    if (cell_index == pc.mouse_cursor_index) {
        if (in_char_x == 0 || in_char_x == uint(pc.char_size.x) - 1 ||
            (sample_coords.y % uint(pc.char_size.y)) == 0 ||
            (sample_coords.y % uint(pc.char_size.y)) == uint(pc.char_size.y) - 1) {
             vec4 t=fg; fg=bg; bg=t;
        }
    }

    uint char_code = cell.char_code;
    if ((flags & (1 << 10)) != 0 && pc.conceal_char_code > 0) {
        char_code = pc.conceal_char_code;
    }
    uint glyph_col = char_code % pc.atlas_cols;
    uint glyph_row = char_code / pc.atlas_cols;

    uint in_char_y = sample_coords.y % uint(pc.char_size.y);
    float u_pixel = float(in_char_x);
    float v_pixel = float(in_char_y);

    // Superscript (19) / Subscript (23) Scaling
    bool is_super = (flags & (1 << 19)) != 0;
    bool is_sub = (flags & (1 << 23)) != 0;
    bool in_glyph_bounds = true;

    if (is_super || is_sub) {
        float scale = 0.6;
        float center_offset_x = (float(pc.char_size.x) * (1.0 - scale)) * 0.5;
        float offset_y = is_super ? 0.0 : (float(pc.char_size.y) * (1.0 - scale));

        float new_u = (u_pixel - center_offset_x) / scale;
        float new_v = (v_pixel - offset_y) / scale;

        if (new_u >= 0.0 && new_u < float(pc.char_size.x) &&
            new_v >= 0.0 && new_v < float(pc.char_size.y)) {
            u_pixel = new_u;
            v_pixel = new_v;
        } else {
            in_glyph_bounds = false;
        }
    }

    if (is_dh_top || is_dh_bot) {
        v_pixel = (v_pixel * 0.5) + (is_dh_bot ? (pc.char_size.y * 0.5) : 0.0);
    }

    float font_val = 0.0;
    if (in_glyph_bounds) {
        ivec2 tex_size = textureSize(font_texture, 0);
        vec2 uv = vec2(float(glyph_col * pc.char_size.x + u_pixel) / float(tex_size.x),
                       float(glyph_row * pc.char_size.y + v_pixel) / float(tex_size.y));

        font_val = texture(font_texture, uv).r;
    }

    // Blink state unpacking
    bool fast_blink_on = (pc.text_blink_state & 1) != 0;
    bool slow_blink_on = (pc.text_blink_state & 2) != 0;
    bool bg_blink_on = (pc.text_blink_state & 4) != 0;

    // Determine effective blink state for this cell
    bool blink_visible = true;
    // SGR 6: Rapid Blink (Bit 4) -> Fast Oscillator
    if ((flags & (1 << 4)) != 0) {
        if (!fast_blink_on) blink_visible = false;
    }
    // SGR 5: Slow Blink (Bit 14) -> Slow Oscillator
    if ((flags & (1 << 14)) != 0) {
        if (!slow_blink_on) blink_visible = false;
    }

    // Blink BG Logic (1 << 13)
    // SGR 66 sets BlinkBG(13).
    // Triggers independent Background Blink.
    bool bg_visible = true;
    if ((flags & (1 << 13)) != 0) {
        if (!bg_blink_on) bg_visible = false;
    }

    if (!bg_visible) {
       bg = vec4(0.0);
    }

    // Calculate Text/Background Color
    vec4 text_layer_color = mix(bg, fg, font_val);

    // Underline (Overlay)
    uint ul_style = (flags >> 20) & 0x7;
    // Fallback for legacy bits if style is 0 but bits are set
    if (ul_style == 0) {
        if ((flags & (1 << 12)) != 0) ul_style = 2; // Double
        else if ((flags & (1 << 3)) != 0) ul_style = 1; // Single
    }

    if (ul_style > 0) {
        vec4 ul = UnpackColor(cell.ul_color);
        bool draw_ul = false;

        if (ul_style == 1) { // Single
            if (in_char_y == uint(pc.char_size.y) - 1) draw_ul = true;
        } else if (ul_style == 2) { // Double
            if (in_char_y == uint(pc.char_size.y) - 1 || in_char_y == uint(pc.char_size.y) - 3) draw_ul = true;
        } else if (ul_style == 3) { // Curly
            // Sine wave with period ~4 pixels (freq 1.5 rad/px -> period ~4.18)
            float w = sin(float(sample_coords.x) * 1.5);
            // Draw at bottom - 2, oscillating +/- 1
            int base_y = int(pc.char_size.y) - 2;
            int offset = int(round(w)); // -1, 0, 1
            if (int(in_char_y) == base_y + offset) draw_ul = true;
        } else if (ul_style == 4) { // Dotted
            if (in_char_y == uint(pc.char_size.y) - 1) {
                if (sample_coords.x % 3 == 0) draw_ul = true;
            }
        } else if (ul_style == 5) { // Dashed
            if (in_char_y == uint(pc.char_size.y) - 1) {
                if ((sample_coords.x % 6) < 4) draw_ul = true;
            }
        }

        if (draw_ul) {
            text_layer_color = mix(text_layer_color, ul, ul.a);
        }
    }

    // Overline (11)
    if ((flags & (1 << 11)) != 0) {
        if (in_char_y == 0) text_layer_color = mix(text_layer_color, fg, fg.a);
    }

    // Framed (16)
    if ((flags & (1 << 16)) != 0) {
        if (in_char_x == 0 || in_char_x == uint(pc.char_size.x) - 1 ||
            in_char_y == 0 || in_char_y == uint(pc.char_size.y) - 1) {
             text_layer_color = mix(text_layer_color, fg, fg.a);
        }
    }

    // Encircled (17)
    if ((flags & (1 << 17)) != 0) {
        float cx = float(pc.char_size.x) * 0.5;
        float cy = float(pc.char_size.y) * 0.5;
        float rx = cx - 0.5; // Slight inset
        float ry = cy - 0.5;

        float dx = float(in_char_x) - cx + 0.5;
        float dy = float(in_char_y) - cy + 0.5;

        float dist_sq = (dx*dx)/(rx*rx) + (dy*dy)/(ry*ry);
        // Approx border check
        if (dist_sq >= 0.8 && dist_sq <= 1.2) {
             text_layer_color = mix(text_layer_color, fg, fg.a);
        }
    }

    // Strike (Overlay)
    if ((flags & (1 << 6)) != 0 && in_char_y == uint(pc.char_size.y) / 2) {
        vec4 st = UnpackColor(cell.st_color);
        text_layer_color = mix(text_layer_color, st, st.a);
    }

    if (!blink_visible) {
       text_layer_color = bg;
    }

    if ((flags & (1 << 10)) != 0) {
       if (pc.conceal_char_code == 0) {
           text_layer_color = bg;
       }
    }

    // Blend Text Layer over Existing (Z < 0) Background
    vec4 pixel_color;
    pixel_color.rgb = text_layer_color.rgb * text_layer_color.a + existing_color.rgb * (1.0 - text_layer_color.a);
    pixel_color.a = text_layer_color.a + existing_color.a * (1.0 - text_layer_color.a);

    // Sixel Blend
    pixel_color = mix(pixel_color, sixel_color, sixel_color.a);

    // Vector Graphics Overlay (Storage Tube Glow)
    if (pc.vector_texture_handle != 0) {
        sampler2D vector_tex = sampler2D(pc.vector_texture_handle);
        vec4 vec_col = texture(vector_tex, uv_screen);
        // Additive blending for CRT glow effect
        pixel_color += vec_col;
    }

    // Scanlines & Vignette (Retro Effects)
    if (pc.scanline_intensity > 0.0) {
        float scanline = sin(uv_screen.y * pc.screen_size.y * 3.14159);
        pixel_color.rgb *= (1.0 - pc.scanline_intensity) + pc.scanline_intensity * (0.5 + 0.5 * scanline);
    }
    if (pc.crt_curvature > 0.0) {
        vec2 d = abs(uv_screen - 0.5) * 2.0;
        d = pow(d, vec2(2.0));
        float vig = 1.0 - dot(d, d) * 0.1;
                pixel_color.rgb *= vig;
    }

    // Visual Bell Flash
    if (pc.visual_bell_intensity > 0.0) {
        pixel_color = mix(pixel_color, vec4(1.0), pc.visual_bell_intensity);
    }

    // Debug Grid
    if ((flags & (1 << 18)) != 0) {
        if (in_char_x == 0 || in_char_x == uint(pc.char_size.x) - 1 ||
            in_char_y == 0 || in_char_y == uint(pc.char_size.y) - 1) {
            vec4 grid_c = UnpackColor(pc.grid_color);
            pixel_color.rgb = grid_c.rgb * grid_c.a + pixel_color.rgb * (1.0 - grid_c.a);
            pixel_color.a = grid_c.a + pixel_color.a * (1.0 - grid_c.a);
        }
    }

    imageStore(output_image, ivec2(pixel_coords), pixel_color);
}
