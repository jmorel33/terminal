# Terminal v2.0 Refactoring Plan

This document outlines the roadmap for version 2.0 of the `terminal.h` library. The primary goals are architectural stability (removing global state), portability (removing compiler-specific extensions), safety (buffer handling), and feature polish.

## Phase 1: Architectural Refactoring (Thread Safety & Instance Management)

**Goal**: Remove the reliance on the global `terminal` struct and make the library instance-based and thread-safe.

### PR 1.1: Introduce Terminal Context Handle
**Objective**: Change the API to operate on a pointer rather than a global object.

- [ ] **Redefine `Terminal` Struct**:
    - Move the definition of `struct Terminal_T` (typedef `Terminal`) to a visible location but encourage usage via pointer.
    - Ensure `Terminal` struct contains all state currently in the global `terminal` variable.
- [ ] **Update Initialization API**:
    - Deprecate/Remove `void InitTerminal(void)`.
    - Introduce `Terminal* Terminal_Create(TerminalConfig config)` which allocates and initializes a new instance.
    - Introduce `void Terminal_Destroy(Terminal* term)` for cleanup.
    - Define `TerminalConfig` struct to pass initial settings (width, height, callbacks, etc.).
- [ ] **Update Callbacks**:
    - Update function pointer typedefs (`ResponseCallback`, `BellCallback`, `TitleCallback`, etc.) to accept `Terminal* term` as the first argument.
    - Update `TerminalSession` to include `void* user_data` for identifying the calling instance in callbacks.

### PR 1.2: Eliminate Global State Macros
**Objective**: Remove the global terminal variable and refactor internal macros.

- [ ] **Remove Global Variable**:
    - Delete `extern struct Terminal_T terminal;` from the header and its definition in the implementation.
- [ ] **Refactor `ACTIVE_SESSION`**:
    - Remove the global macro `#define ACTIVE_SESSION (terminal.sessions[terminal.active_session])`.
    - Introduce a macro or inline function `GET_SESSION(term)` that resolves to `(&(term)->sessions[(term)->active_session])`.
- [ ] **Update Internal Functions**:
    - Refactor every internal function (e.g., `ProcessChar`, `DrawTerminal`, `ExecuteCSICommand`) to accept `Terminal* term` as a parameter.
    - Update all references inside these functions to use `term->` instead of `terminal.`.
    - Propagate the `term` pointer down the entire call stack.
- [ ] **Update External API**:
    - Update public functions (e.g., `PipelineWriteChar`, `SetVTLevel`) to take `Terminal* term`.

## Phase 2: Portability & Code Hygiene

**Goal**: Remove non-standard C extensions and improve developer experience with shaders.

### PR 2.1: Replace Computed Gotos with Switch-Case
**Objective**: Remove GCC-specific `&&label` extension to support MSVC and standard C compilers.

- [ ] **Locate `ExecuteCSICommand`**:
    - Identify the `static const void* const csi_dispatch_table[256]` and the `goto *target` logic.
- [ ] **Refactor Logic**:
    - Replace the dispatch table with a standard `switch (command) { case 'A': ... }` block.
    - Move the logic from the labels (e.g., `L_CSI_A:`) into the corresponding `case` blocks.
    - Ensure the `default` case handles unsupported sequences (formerly `L_CSI_UNSUPPORTED`).
- [ ] **Rationale**: Modern compilers optimize dense switch statements into jump tables automatically. This removes a non-portable GNU extension.

### PR 2.2: Shader Code Externalization (or Clean Embedding)
**Objective**: Make shader code readable and editable.

- [ ] **Remove Macro Definitions**:
    - Remove `#define TERMINAL_SHADER_BODY "..."` style macros which are hard to edit.
- [ ] **Implement `const char*` Constants**:
    - Move shader code to the bottom of the implementation section as `const char* terminal_vs_source = ...;`.
    - Use C string literal concatenation (implicit) instead of line-continuation backslashes for multi-line strings.
    - Example:
      ```c
      const char* shader_source =
      "#version 450\n"
      "void main() {\n"
      "   ...\n"
      "}\n";
      ```
- [ ] **(Optional) Tooling**: Create a pre-build script to convert `.glsl` files to C headers.

## Phase 3: Safety & Robustness

**Goal**: Fix buffer overflow risks in the ReGIS and generic string parsers.

### PR 3.1: Introduce Safe Parsing Primitives
**Objective**: Create a standardized way to parse data streams safely.

- [ ] **Define `StreamScanner`**:
    ```c
    typedef struct {
        const unsigned char* ptr;
        size_t len;
        size_t pos;
    } StreamScanner;
    ```
- [ ] **Implement Helper Functions**:
    - `Stream_Peek(scanner)`: Safe peek.
    - `Stream_Consume(scanner)`: Safe advance.
    - `Stream_ReadInt(scanner)`: Parse integer safely.
    - `Stream_Expect(scanner, char)`: Verify expected character.
    - Ensure all helpers check `if (pos >= len)` and handle bounds gracefully.

### PR 3.2: Refactor ReGIS and Parsing Logic
**Objective**: Apply safe primitives to critical areas.

- [ ] **Refactor `ProcessReGISChar`**:
    - Replace raw pointer arithmetic (e.g., `ptr++`, `while(*ptr)`) with `StreamScanner` functions.
- [ ] **Refactor Soft Font Loading**:
    - In `ProcessSoftFontDownload` (or `ProcessDCSChar` handling `DECDLD`), ensure font data parsing respects buffer limits.
- [ ] **Harden Escape Buffers**:
    - In `ProcessCSIChar`, `ProcessOSCChar`, `ProcessDCSChar`:
    - Check if `active_session->escape_pos` exceeds `MAX_COMMAND_BUFFER` before appending.
    - Implement truncation or error logging on overflow.

## Phase 4: Feature Polish (BiDi & Unicode)

**Goal**: Cleanup strict Unicode/BiDi handling.

### PR 4.1: Unicode Strictness
**Objective**: Ensure invalid UTF-8 sequences do not corrupt state.

- [ ] **Update Decoder**:
    - In `ProcessNormalChar` (or the UTF-8 state machine), check for invalid sequences (e.g., overlong encodings, unexpected continuation bytes).
    - Upon error, immediately emit the Replacement Character (U+FFFD) and reset the decoder state.
- [ ] **Visual Feedback**:
    - Ensure `AllocateGlyph` specifically handles `U+FFFD` by rendering a distinct glyph (e.g., `?` inside a diamond/box) instead of a space or null.

## Recommended Execution Order
1. **PR 2.1 (Computed Gotos)**: Low hanging fruit, high impact on portability.
2. **PR 1.1 & 1.2 (Global State)**: The heaviest lift. Doing this early prevents merge conflicts later.
3. **PR 3.1 & 3.2 (Buffer Safety)**: Critical for security, but easier to implement once the `Terminal*` context is passed around correctly.
4. **PR 2.2 (Shaders)**: Quality of life improvement, can be done anytime.
